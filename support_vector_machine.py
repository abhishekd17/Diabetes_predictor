# -*- coding: utf-8 -*-
"""Support_Vector_Machine.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mVXJXK-JWN4EFiuoW-ECLru9Umc2XhSJ
"""

#SVM Classifier
import numpy as np

class SVM_classifier():
  #initiating the hyperparameters
  def __init__(self , learning_rate , no_of_iterations , lambda_parameter):
    self.learning_rate=learning_rate
    self.no_of_iterations=no_of_iterations
    self.lambda_parameter=lambda_parameter

  # fitting the dataset to svm classifier
  def fit(self ,X,Y):
    #m--> number of data points --> number of rows
    # n --> number of input features
    self.m , self.n=X.shape
    # initiating the weight value and bias value
    self.w=np.zeros(self.n)
    self.b=0
    self.X=X
    self.Y=Y
    #gradient descent
    for i in range(self.no_of_iterations):
      self.update_weights()


  # function for updating weight and bias
  def update_weights(self ,):
    # 0 to -1
    y_label=np.where(self.Y<=0 ,-1 ,1)

    for index ,x_i in enumerate(self.X):
      condition=y_label[index]*(np.dot(x_i,self.w)-self.b)>=1
      if condition:
        dw=2*self.lambda_parameter*self.w
        db=0
      else:
        dw=2*self.lambda_parameter*self.w-np.dot(x_i,y_label[index])
        db=y_label[index]
      self.w=self.w-self.learning_rate*dw
      self.b=self.b-self.learning_rate*db

  # predict the label for a given input value
  def predict(self, X ):
    output=np.dot(X,self.w)-self.b
    predicted_labels=np.sign(output)
    # -1 to 0
    y_hat=np.where(predicted_labels <= -1 ,0,1)
    return y_hat

